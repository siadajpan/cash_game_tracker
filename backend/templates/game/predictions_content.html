<div class="row g-4">
    <div class="col-12">
        <div class="table-responsive">
            <table class="table table-hover table-hover-custom align-middle mb-0 user-select-none">
                <thead class="table-light">
                    <tr>
                        <th class="ps-3 border-bottom-0 py-2">Player</th>
                        <th class="text-center border-bottom-0 py-2">Win Probability</th>
                        <th class="text-end pe-3 border-bottom-0 py-2">Model Reliability</th>
                    </tr>
                </thead>
                <tbody>
                    {% for pred in predictions %}
                    <tr class="player-row" style="cursor: pointer; transition: opacity 0.2s;"
                        onclick="togglePlayerSelection('{{ pred.player.nick or pred.player.username }}')"
                        data-nick="{{ pred.player.nick or pred.player.username }}">
                        <td class="ps-3 py-2">
                            <div class="d-flex align-items-center">
                                <div class="rounded-circle me-2"
                                    style="width: 12px; height: 12px; background-color: {{ pred.color }}; border: 1px solid rgba(0,0,0,0.1);">
                                </div>
                                <span class="fw-semibold">{{ pred.player.nick or pred.player.username }}</span>
                            </div>
                        </td>
                        <td class="text-center py-2">
                            <span
                                class="fw-bold {% if pred.win_prob > 50 %}text-success{% else %}text-secondary{% endif %}">
                                {{ "%.1f"|format(pred.win_prob) }}%
                            </span>
                        </td>
                        <td class="text-end pe-3 py-2">
                            <span
                                class="badge {% if pred.n_games < 5 %}bg-warning text-dark{% elif pred.n_games < 15 %}bg-info text-dark{% else %}bg-success{% endif %}">
                                {{ pred.reliability }}
                            </span>
                            <small class="text-muted ms-1" style="font-size: 0.75rem;">({{ pred.n_games }}g)</small>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>

    <div class="col-12 mt-4 border-top pt-4 position-relative">
        <div id="resetSelectionBtn" class="position-absolute start-50 translate-middle-x d-none"
            style="top: -15px; z-index: 20;">
            <button class="btn btn-sm btn-outline-secondary bg-white shadow-sm rounded-pill px-3"
                onclick="resetSelection()">
                <i class="bi bi-x-circle me-1"></i> Reset Selection
            </button>
        </div>
        <h6 class="fw-bold mb-3 text-center text-uppercase text-muted" style="letter-spacing: 0.05em;">Expected Outcome
            Distribution</h6>
        <div id="chartContainer" style="height: 350px; width: 100%; position: relative; min-height: 300px;">
            <div id="chartLoading" class="d-flex justify-content-center align-items-center text-muted"
                style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; background: rgba(255,255,255,0.8);">
                <span><i class="bi bi-activity me-2"></i> Loading chart...</span>
            </div>
            <canvas id="predictionChart"></canvas>
        </div>
        <p class="text-center text-muted mt-3 small">
            <i class="bi bi-info-circle me-1"></i>
            Higher peaks indicate more consistent players. Wider curves indicate higher variance ("swingy" playstyle).
        </p>
    </div>
</div>

<script id="predictions-data" type="application/json">
    {{ chart_data | tojson | safe }}
</script>

<script>
    (function () {
        let attempts = 0;
        const maxAttempts = 50; // 10 seconds total
        let selectedPlayers = new Set();
        let chartInstance = null;

        const resetSelectionBtn = document.getElementById('resetSelectionBtn');

        // Toggle Player Selection
        window.togglePlayerSelection = function (nick) {
            if (selectedPlayers.has(nick)) {
                selectedPlayers.delete(nick);
            } else {
                selectedPlayers.add(nick);
            }
            updateChartVisibility();
            updateTableStyles();
            updateResetButton();
        };

        window.resetSelection = function () {
            selectedPlayers.clear();
            updateChartVisibility();
            updateTableStyles();
            updateResetButton();
        };

        function updateResetButton() {
            const btn = document.getElementById('resetSelectionBtn');
            if (selectedPlayers.size > 0) {
                btn.classList.remove('d-none');
            } else {
                btn.classList.add('d-none');
            }
        }

        function updateTableStyles() {
            document.querySelectorAll('.player-row').forEach(row => {
                const nick = row.getAttribute('data-nick');
                if (selectedPlayers.size === 0) {
                    row.classList.remove('table-active');
                    row.style.opacity = '1';
                } else if (selectedPlayers.has(nick)) {
                    row.classList.add('table-active');
                    row.style.opacity = '1';
                } else {
                    row.classList.remove('table-active');
                    row.style.opacity = '0.5';
                }
            });
        }

        function updateChartVisibility() {
            if (!chartInstance) return;

            chartInstance.data.datasets.forEach(dataset => {
                if (selectedPlayers.size === 0) {
                    // Reset to default
                    dataset.borderColor = dataset.originalColor;
                    dataset.backgroundColor = dataset.originalColor + '15';
                    dataset.borderWidth = dataset.originalBorderWidth;
                } else {
                    if (selectedPlayers.has(dataset.label)) {
                        // Selected: Highlight
                        dataset.borderColor = dataset.originalColor;
                        dataset.backgroundColor = dataset.originalColor + '25';
                        dataset.borderWidth = 4;
                    } else {
                        // Unselected: Dim
                        dataset.borderColor = dataset.originalColor + '40'; // High transparency
                        dataset.backgroundColor = dataset.originalColor + '05';
                        dataset.borderWidth = 1;
                    }
                }
            });
            chartInstance.update('none'); // Update without animation for responsiveness
        }

        const initChart = () => {
            console.log('Starting initChart...');
            const loader = document.getElementById('chartLoading');
            const showError = (msg) => {
                if (loader) loader.innerHTML = `<span class="text-danger"><i class="bi bi-exclamation-triangle-fill me-2"></i>${msg}</span>`;
            };

            // 1. Check if Chart.js is loaded
            if (typeof Chart === 'undefined') {
                attempts++;
                if (attempts > maxAttempts) {
                    console.error('Chart.js failed to load after multiple attempts.');
                    showError('Oops! The chart library failed to load. Please refresh the page.');
                    return;
                }
                setTimeout(initChart, 200);
                return;
            }

            // 2. Locate elements
            const canvas = document.getElementById('predictionChart');
            const container = document.getElementById('chartContainer');
            if (!canvas || !container) {
                return;
            }

            // 3. Wait for visibility (critical for modal)
            if (container.offsetWidth === 0 || container.offsetHeight === 0) {
                attempts++;
                if (attempts > maxAttempts) {
                    console.warn('Container not visible after timeout.');
                } else {
                    setTimeout(initChart, 200);
                    return;
                }
            }

            console.log('Canvas context found');
            const ctx = canvas.getContext('2d');

            // 4. Helper Function
            function normalPDF(x, mu, sigma) {
                if (sigma <= 0) return 0;
                const a = 1 / (sigma * Math.sqrt(2 * Math.PI));
                const b = -0.5 * Math.pow((x - mu) / sigma, 2);
                return a * Math.exp(b);
            }

            // 5. Parse Data
            let predictions = [];
            try {
                const dataElement = document.getElementById('predictions-data');
                if (dataElement && dataElement.textContent) {
                    predictions = JSON.parse(dataElement.textContent);
                }
            } catch (e) {
                console.error('Failed to parse predictions JSON', e);
                showError('Failed to load chart data.');
                return;
            }

            if (predictions.length === 0) {
                showError('No data available to display.');
                return;
            }

            try {
                // 6. Calculate Range
                let minX = Infinity;
                let maxX = -Infinity;

                predictions.forEach(p => {
                    minX = Math.min(minX, p.mu - 2 * p.sigma);
                    maxX = Math.max(maxX, p.mu + 2 * p.sigma);
                });

                if (minX === Infinity) { minX = -1000; maxX = 1000; }
                if (minX === maxX) { minX -= 500; maxX += 500; }

                minX = Math.floor(minX / 100) * 100;
                maxX = Math.ceil(maxX / 100) * 100;

                const labels = [];
                const segments = 120;
                const stepSize = (maxX - minX) / segments;
                for (let i = 0; i <= segments; i++) {
                    labels.push(Math.round(minX + i * stepSize));
                }

                // 7. Render Chart
                const datasets = predictions.map(p => {
                    const isLowReliability = p.reliability && p.reliability.startsWith('Low');
                    const width = isLowReliability ? 1 : 3;
                    return {
                        label: p.label,
                        data: labels.map(x => normalPDF(x, p.mu, p.sigma)),
                        borderColor: p.color,
                        backgroundColor: p.color + '15',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                        borderWidth: width,
                        borderDash: isLowReliability ? [4, 4] : [],
                        // Custom properties for state management
                        originalColor: p.color,
                        originalBorderWidth: width
                    };
                });

                if (window.myPredictionChart instanceof Chart) {
                    window.myPredictionChart.destroy();
                }

                console.log('Creating new Chart instance...');
                window.myPredictionChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels, datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                            legend: { display: true, position: 'bottom' },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: (ctx) => ctx.dataset.label + ': ' + (ctx.parsed.y * 1000).toFixed(4)
                                }
                            }
                        },
                        scales: {
                            x: { display: true, grid: { display: false } },
                            y: { display: false }
                        },
                        onClick: (e, activeEls) => {
                            // Optional: Click on chart line to select?
                            // Leaving out for now to focus on table interaction as requested
                        }
                    }
                });

                chartInstance = window.myPredictionChart;

                // Success! Hide loader
                if (loader) {
                    loader.classList.remove('d-flex');
                    loader.style.display = 'none';
                }

            } catch (e) {
                console.error('Chart rendering error:', e);
                showError('Error rendering chart: ' + e.message);
            }
        };

        // Start initialization
        setTimeout(initChart, 300);
    })();
</script>